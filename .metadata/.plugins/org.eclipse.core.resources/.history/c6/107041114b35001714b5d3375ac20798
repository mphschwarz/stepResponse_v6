
package pro2e.teamX.matlabfunctions;

import org.apache.commons.math3.complex.Complex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;

import java.util.Arrays;

import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;
import org.apache.commons.math3.util.FastMath;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.XsiNilLoader.Array;

import pro2e.teamX.matlabfunctions.NelderMeadSimplexSinusCosExample.Target;
import pro2e.teamX.userinterface.PNSEbene;

public abstract class MatlabFunktionen {
	public NelderMeadSimplexSinusCosExample nelderMeadSimplexSinusCosExample;
	public double[][] c0 = new double[10][10];
	static double[] w;
	static double[] q;
	static double betrag;
	    static double []c;
	    

	public static final double[] error(double[] c, double[] t, double[] x, int n) {
		double[] r = new double[x.length];
		double[] y = stepResponse(c, t, n);
		for (int i = 0; i < x.length; i++) {

			r[i] += Math.pow((y[i] - x[i]), 2);
		}
		return r;

	}

	public static double[] butterIniC(double k, int n, int N) {
		if (n % 2 == 0) {
			n = n / 2;

			double[] l = Matlab.linspace(Math.PI / 2, Math.PI, n + 1);
			double[] re = new double[n+1 ];

			for (int i = 0; i < n; i++) {
				re[i] = Math.cos(l[i]);
			}
			double[] im = new double[n+1];
			for (int i = 0; i < n; i++) {
				im[i] = Math.sin(l[i]);
			}
			w = new double[n+1];
			for (int i = 0; i < n; i++) {

				w[i] = Math.sqrt(Math.pow(re[i], 2) + Math.pow(im[i], 2));
			}
			double[] abs = new double[n+1];
			for (int i = 0; i < n; i++) {

				abs[i] = Math.abs(re[i]);
			}
			for (int i = 0; i < n; i++) {
				q = new double[n+1];
				q[i] = w[i] / (2 * abs[i]);
			}
			 c = new double[11];
			c = Matlab.concat(w, q);
			
			
			//            for (int i=0;i<=w.length*2;i++){
			//          
			//               c[i]=w[i];        
			//               c[i+1]=q[i];  
			//                      
			//                 }    
		}

		//		else{
		//            n=n-1/2;
		//            double []re=Matlab.linspace(Math.PI/2,Math.PI,n+1);
		//            for (int i=0;i<n;i++){
		//                 re[i]=Math.cos(re[i]);
		//            }
		//            double []im=Matlab.linspace(Math.PI/2,Math.PI,n+1);
		//            for (int i=0;i<n;i++){
		//                 im[i]=Math.sin(im[i]);
		//            }w=new double [N];
		//            for (int i=0;i<n;i++){
		//            	
		//                 w[i]=Math.sqrt(Math.pow(re[i],2)+Math.pow(im[i],2));
		//            }
		//            for (int i=0;i<n;i++){
		//                 betrag = betrag + re[i];
		//            }
		//            for (int i=0;i<n;i++){
		//                 q=new double[n];
		//                 q[i]=w[i]/(2*betrag);
		//            }
		//            c=new double[N];
		//            c[0]=k;
		//            for (int i=1;i<=n*2;i++){
		//                 if(i%2==0){
		//                      c[i]=q[(i/2)-1];
		//                 }else{
		//                      c[i]=w[(i/2)]; 
		//                 }    
		//            }
		//    }
		return c;
	}

	public static double[] stepResponse(double[] c, double[] t, int n) {
		int den = 1;
		double[] k = new double[c.length];
		k[0] = c[0];
		System.arraycopy(c, 1, c, 0, c.length);
		if (c.length % 2 == 1) {
			int odd = 1;

		}
		return t;

	}

	public static Object[] optStep(double[] t, double[] x, int ns, int ne, double[] c) {
		double[] c0 = new double[10];
		double[] val = new double[10];
		double[] iter = new double[10];
		double[] ef = new double[10];
		SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);//
		Target target = new Target();
		PointValuePair optimum = optimizer.optimize(new MaxEval(1000), new ObjectiveFunction(target), GoalType.MINIMIZE,
				new InitialGuess(new double[] { 7, 3.5 }), new NelderMeadSimplex(new double[] { 0.02, 0.02 }));

		System.out.println(Arrays.toString(optimum.getPoint()) + " : " + optimum.getSecond());

		for (int r = 1; r < ns - ne; r++) {
			optimum.getValue();
		}

		return null;

	}
	public static Object[] genFraq(double [] c, int n){
		double num = c[0];
		double[] den = new double [n+1];
		den[0] = 1;
		boolean even = true;
		if(n%2 == 1){
			den = Matlab.conv(new double[]{1,Math.abs(c[n])},den);
			n = n-1;
			even = false;
		}
		for (int i = 1; i < n; i=i+2) {
			num = num * Math.pow(c[i], 2);
			den = Matlab.conv(new double[]{1, c[i]/c[i+1], Math.pow(c[i], 2)}, den);
		}
		if (even==true)
			den = Matlab.colon(den, 0, n);
		else
			den = Matlab.colon(den, 0, n+1);
		
		return new Object []{num,den};
	}
	
	public static Object[] findpeaks(double [] x0){
		int [] p = new int [x0.length];
		double[] x = new double [x0.length];
		int k = 0;
		for (int i = 1; i < x.length-2; i++) {
			if(x0[i+1]==x0[i]){
				int m = 0;
				for (int j = i; x0[j+1]==x0[j]&&j+2<x0.length; j++) {
					if(x0[j+2]<x0[j+1] && x0[i-1]<x0[i]){
						x[k] = x0[i];
						p[k] = i;
						k++;
					}
					m = j+1;
				}
				i = m;
			}
			if(x0[i-1]<x0[i] && x0[i+1]<x0[i]){
				x[k] = x0[i];
				p[k] = i;
				k++;
			}
		}
		x = Matlab.colon(x, 0, k-1);
		p = Matlab.colon(p, 0, k-1);
		return new Object []{x,p};
	}
	
	public static Object[] normT(double [] x0, double [] t0){
		double T = 1;
		double[] t = new double [t0.length];
		int [] pi = new int [x0.length];
		//x0 = movmean(x0,100);
		Object[] res = findpeaks(x0);
		pi = (int[]) res[1];
		if(pi.length>=2){
			T = Math.abs(t0[pi[0]]-t0[pi[1]]);
			for (int i = 0; i < t0.length; i++) {
				t[i] = t0[i]/T;
			}
		}
		else{
			T = 0;							//wenn keine 2 Maxima
			t = Matlab.zeros(t0.length);
		}
		return new Object []{T,t};
	}

	public static void main(String[] args) {
		double[] dubidu = Matlab.linspace(Math.PI / 2, Math.PI, 2);
		double[] buttterinic = new double [11];
		double[] c={1,2,3,4,5,6,7,8,9,10,11};
		int n=1;
		Filter filter;
		filter=FilterFactory.createButter(5, 1e3);
		System.out.println(""+filter.rA);
		Object[] res=genFraq(c, n);
		double num=(double) res[0];
		double[] den=(double[]) res[1];
		buttterinic = butterIniC(1, 8, 11);
//		for (int i = 0; i < dubidu.length; i++) {
//			System.out.println("" + dubidu[i]);
//		}


		System.out.println("num: "+num);
		for (int i = 0; i < den.length; i++) {
			System.out.println("den: "+den[i]);
		}

	}


	private static class Target implements MultivariateFunction {// Fehlerfunktion 
		public double value(double[] variables) {
			final double x = variables[0];
			final double y = variables[1];
			return FastMath.cos(x) * FastMath.sin(y);
		}
	}
}
